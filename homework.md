# 1. Написать функцию суммирования значений

Написать функцию sum, которая может быть исполнена любое количество раз.
Если она исполнена без аргументов, то возвращает значение суммы всех переданных до этого значений.

sum(1)(2)(3)....(n)() === 1 + 2 + 3 + ... + n

```javascript
sum(undefined)() // undefined
sum(1)() // 1
sum(1)(2)(3)(4)()  // 10
sum(0)(5)(3)(8)(-2)() // 14
sum(1)(1)(1)(1)(1)(1)(1)() // 7
```

# 2. Promise reduce

Написать функцию `promiseReduce`, которая получает на вход
- массив асинхронных функций `asyncFunctions`, возвращающих `Promise`,
- `reduce` функцию и
- стартовое значение `initialValue`.

`promiseReduce` поочередно вызывает переданные асинхронные функции
и выполняет `reduce` функцию сразу при получении результата до вызова следующей асинхронной функции.

`reduce` должна отрабатывать аналогично [`Array.prototype.reduce`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce), то есть запоминать результат предыдущей итерации

Пример

```javascript
var fn1 = () => {
  console.log('fn1')
  return Promise.resolve(1)
}

var fn2 = () => new Promise(resolve => {
  console.log('fn2')
  setTimeout(() => resolve(2), 1000)
})

function promiseReduce(asyncFunctions, reduce, initialValue) {
  /*
  * Сюда нужно дописать работающий код
  */
}

promiseReduce(
  [fn1, fn2],
  function (memo, value) {
    console.log('reduce')
    return memo * value
  },
  1
)
.then(console.log)
```

Вывод в консоль

```
fn1
reduce
fn2
reduce
2
```

---


```javascript
var fn1 = () => fetch('https://jsonplaceholder.typicode.com/posts/1').then(r => r.json())
var fn2 = () => fetch('https://jsonplaceholder.typicode.com/posts/2').then(r => r.json())

promiseReduce(
  [fn1, fn2],
  function(memo, value) {
    return memo + value.id
  },
  0
)
.then(console.log)
```

# 3 Реализовать скрипт request для тестирования веб сервера

Создать локальный веб сервер `server`, отвечающий на запросы каждые 100ms

Создать скрипт `request`, принимающий на вход
  - количество запросов `N`
  - тип запросов - параллельный или последовательный

Скрипт `request` должен отправлять `N` последовательных или параллельных `HTTP` запросов к локальному серверу `server`

# 4 Node File System

Напишите `NodeJS` скрипт `tree` для вывода списка файлов и папок файловой системы.
Результатом работы должен быть объект с массивами `{ files, folders }`.
Вызовы файловой системы должны быть асинхронными.
Скрипт принимает входной параметр - путь до папки.
Добавить возможность выполнять этот скрипт через команду `npm run tree -- path`

Пример

```
foo/
├── bar/
│├── bar1.txt
│├── bar2.txt
│└── baz/
├── f1.txt
└── f2.txt
```

При вызове с путем `foo/` скрипт должен вернуть структуру:

```json
{
  "files": [
    "foo/f1.txt",
    "foo/f2.txt",
    "foo/bar/bar1.txt",
    "foo/bar/bar2.txt"
  ],
  "dirs": [
    "foo",
    "foo/bar",
    "foo/bar/baz"
  ]
}
```

# 8 Node Rest API RSS

Написать `NodeJS Rest API` приложение для сохранения `RSS` рассылок.
В приложении должно быть следующие точки доступа
- Создание рассылки по `URL`. При успешном добавлении приложение будет запрашивать `RSS` рассылку, парсить `XML` и сохранять документы в базу данных.
- Показ списка всех добавленных `URL` рассылок.
- Показ всех сохраненных из `RSS` документов.

Приложение должно содержать тесты для всех точек доступа.

# 9 Write a `getPath` function to get a unique element's selector

Написать алгоритм и функцию getPath, находяющую уникальный css-селектор для элемента в документе.
Уникальный селектор может быть использован document.querySelector() и возвращать исходный элемент.
document.querySelectorAll(), вызванный с этим селектором, не должен находить никаких элементов кроме исходного.

```javascript
node // HTMLElement
getPath(node) // => "..."
```

# 10 Custom Elements Tree

С помощью `Custom Elements` создать приложение для показа дерева с помощью компонентов `my-tree` и `my-leaf`.
Компоненты должны получать данные о структуре поддерева от родительского элемента.
Используйте `Shadow DOM` при отрисовке компонент.

Пример стуктуры

```json
{
  "id": 1,
  "items": [{
    "id": 2,
    "items": [{ "id": 3 }]
  }]
}
```

# 12 Polymer RSS App

Сделать приложение на `Polymer` для показа и добавления `RSS` рассылок из задания `#8`.
Можно использовать готовые `iron` компоненты - https://www.webcomponents.org/author/PolymerElements

Должны быть реализованы следующие функции:
- Создание рассылки по `URL`
- Показ списка всех добавленных `URL` рассылок
- Показ всех сохраненных из `RSS` документов

Приложение должно содержать тесты для всех элементов `UI`

# 24 TypeScript



# 26 Angular Common

Приложение для запоминания иностранных слов. В этом приложении пользователь сможет добавлять слова для изучения, проходить тесты для запоминания слов. Это Single Page Application состоит из 3 страниц:
Последние добавленные слова (Recently Added)
Упражнениями (Go)
Настройки (Settings)
На главном экране, на странице Recently Added пользователь видит список последних добавленных слов, может добавить новое слово в словарь (если успеем, будем делать также статистику изучения слов).

На странице упражнений пользователь занимается тестированием своих знаний. Ему показывается слово на одном языке, и он должен написать его перевод на другой язык. Если перевод правильный, слово засчитывается, иначе показываем ошибку. Мы начнем с двух языков - русского и английского, будем расширять возможности приложения по мере написания программы.

На странице настроек пользователь выбирает языки, количество слов в упражнении, отводимое на упражнение время.

Навигация по страницам происходит с помощью ссылок в верхней части страниц, каждой странице соответствует отдельный url.

Декомпозировать приложение для запоминания иностранных слов.
Создать структуру и компоненты контейнеры приложения.

# 26 Angular Services

Создать сервисы для работы с текстом
- Сервис перевода слова - должен запрашивать перевод через API (например, https://tech.yandex.com/translate/)
- Сервис хранения словаря - небольшая обертка для управления словарем с помощью `localStorage`
- Сервис добавления слов - должен разбивать текст на отдельные слова, запрашивать их перевод и сохранять в словарь для приложения.

Сервисы должны общаться с помощью библиотеки `RxJS`.

# 28 Angular Components

Реализовать `UI` приложения
- Создать компоненты для добавления текста/слов в словарь
- Разработать компоненты и формы для тренировки запоминания слов
- Добавить экран настройку приложения, сохранять состояние

# 30 Anguar Routing

Для приложения запоминания иностранных слов создать routing - добавить ссылки на страницы и переходы между компонентами приложения.
Добавить и актуализировать тесты для компонент приложения, настроить universal рендеринг приложения.

---

[Пример "хороших" комментариев к работе](https://github.com/lJarSl/mitsuk-margarita-otus/pull/3#pullrequestreview-151617091)